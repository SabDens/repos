#include <ios>
#include <ostream> // output stream <<
#include <istream> // input stream >>
#include <iostream>
#include <fstream>
// #include <sstream>



int main() {

	std::cout << "Hwllo!\n"; // Вывод в стандартный поток вывода (обычно консоль)
	std::cerr << "Hwllo!\n"; // Вывод в поток ошибок (обычно для сообщений об ошибках)
	std::clog << "Hwllo!\n"; // Вывод в поток логов (обычно для отладки)

	/*
	-------------------------------- Ієрархія потоків вводу / виводу в C++ --------------------------------
	
	1. std::cout – це стандартний потік виводу, який використовується для нормального виводу інформації у програмі.
	Він буферизується, що означає, що дані зберігаються в пам'яті перед їх надсиланням в консоль/термінал.
	Це може покращити продуктивність, оскільки кілька операторів виводу можна об'єднати в одну операцію.
	
	2. std::cerr – це стандартний потік виводу помилок, який використовується для повідомлень про помилки
	та діагностичного виведення. Він не буферизується, що означає, що дані надсилаються безпосередньо на консоль
	або термінал, як тільки вони записуються. Це гарантує, що повідомлення про помилки відображаються миттєво
	та не втрачаються в разі збою програми.
	
	3. std::clog – це стандартний потік логування, який використовується для реєстрації повідомлень.
	Він буферизується як std::cout, але зазвичай використовується для реєстрації інформації,
	яка не є критичною для роботи програми.
	
	----------------------------------------------------------------------------------------------
	*/




	// --------------------------------- Як поламати потік? ---------------------------------
	// 
	// В кожному класі з нашої ієрархії є поле, яке називається _Mystate. Воно має тип int і відповідає за стан потоку.
	// Стан може бути добрим (пологодженням / з яким можна працювати) або поганим (який треба або полагодити
	// або перестати з ним працювати). В ньому записується одне з 4 можливих значень:
	// 
	// 1. std::ios::goodbit – відповідає за те, що потік працює нормально. Встановлюється за замовчуванням 
	//    при створенні потоку.
	// 2. std::ios::eofbit – встановлюється тоді, коли при зчитуванні даних з потоку ми зустріли кінець файлу.
	// 3. std::ios::failbit – встановлюється тоді, коли відбулася помилка, яку можна виправити. 
	//    Наприклад, коли потік не може читати чи записувати дані із-за тимчасового
	//    збою в мережі чи дані не відповідають очікуваному формату.
	// 4. std::ios::badbit – встановлюється тоді, коли відбулася помилка, яку не можна виправити. 
	//    Наприклад коли потік не може зчитувати / записувати дані із-за апаратного збою,
	//    чи потік неочікувано закрився.
	// 
	// Щоб перевірити стан потоку, існують 4 методи: good(), eof(), fail(), bad().
	// Вони повертають true, якщо встановлений один з 4 бітів.
	// 
	// Ось приклад на перевірку цих бітів:

	/*{
		std::cout << "Enter a number: ";
		int number;
		std::cin >> number;

		if (std::cin.good()) {
			std::cout << "Your number = " << number << std::endl;
		}
		else {
			std::cout << "Oops. Something went wrong.\n";
			if (std::cin.bad()) {
				std::cout << "cin.bad() = true.\n";
			}
			else if (std::cin.fail()) {
				std::cout << "cin.fail() = true.\n";
			}
			else if (std::cin.eof()) {
				std::cout << "cin.eof() = true.\n";
			}
		}
	}*/
	
	// -------------------------------- Як полагодити потік? --------------------------------
	//
	// 1. Якщо стан потоку має значення std::ios::eofbit, то в такому випадку
	//    потік дійшов до кінця запису / зчитування і вам треба його закрити та заново відкрити.
	//    Робиться це методами close та open. Це відбувається зазвичай при роботі з файлами.
	//
	// 2. Якщо стан потоку має значення std::ios::failbit, то в такому випадку
	//    ви можете спочатку викликати метод clear(), який встановить стан потоку
	//    заново в значення std::ios::goodbit, а потім почистити потік методом ignore(),
	//    який витягне звідти символи, але не запише їх в потік (щоб він заново не поламався).
	//    Після цього можна продовжити роботу.
	//
	// 3. Якщо стан потоку має значення std::ios::badbit, то в такому випадку
	//    ви можете викликати метод clear(), але це не гарантує, що потік зможе спокійно працювати далі,
	//    так як такий біт встановлюється у "невиправних" ситуаціях. Тут рекомендується більше
	//    не працювати з потоком, а відкрити новий (або закрити і відкрити цей).
	//
	// Приклад полагодження:

	//{
	//	std::cout << "Enter a number: ";
	//	int number;
	//	std::cin >> number;
	//
	//	while (!std::cin.good() && std::cin.fail()) {
	//		std::cin.clear(); // Сброс состояния потока
	//		std::cout << "You entered incorrect value. Enter only integer number.\n";
	//		std::cin.ignore(LLONG_MAX, '\n'); // Игнорирование оставшихся символов в потоке
	//		std::cout << "Enter a number: ";
	//		std::cin >> number; // Повторный ввод
	//	}
	//
	//}

	// -------------------------------- Режими відкриття файлу --------------------------------
	//
	// 1. std::ios::in    – відкрити файл для читання. Якщо файлу не існує – потік "ламається".
	// 2. std::ios::out   – відкрити файл для запису. Якщо файл існує – його вміст очищається (можливо).
	//                      Якщо не існує – файл створюється.
	// 3. std::ios::app   – відкрити файл для запису в кінець. Якщо файлу не існує – він створюється.
	// 4. std::ios::trunc – використовується з режимом out. Змушує файл очиститися, якщо 
	//                      в ньому було щось до відкриття.
	// 5. std::ios::ate   – використовується з іншими режимами. Переміщує вказівник зчитування в кінець файлу.
	// 6. std::ios::binary – відкрити файл у бінарному режимі. Використовується з іншими режимами.
	// ------------------------------ Файловий покажчик ------------------------------
	//
	// peek() – повертає наступний символ відносно курсору читання не зміщуючи курсор
	// tellp(), tellg() – повертають поточну позицію у файлі.
	//
	// tellg() – повертає позицію курсора читання. (ifstream)
	// tellp() – повертає позицію курсора запису. (ofstream)
	//
	// Методи seekp()/seekg() приймають два параметри: вихідна точка (origin) та зміщення від неї (offset)
	//
	// seekg() – встановлює позицію курсора читання.
	// seekp() – встановлює позицію курсора запису.
	//
	// Методи які зміщують курсор читання:
	// ignore() – Пропускає вказану кількість символів у потоці, зміщуючи курсор на n позицій.
	// get() – Читає один символ і зміщує курсор на один байт вперед.
	// getline() – Зчитує рядок і зміщує курсор на наступний рядок.
	// read() – Читає n байтів і зміщує курсор читання на n байтів вперед.
	// putback() – Повертає символ у потік.
	// unget() – Зміщує курсор назад на один символ.
	//
	// Методи які зміщують курсор запису:
	// put() – Записує символ у потік.
	// write() – Записує n байтів у потік.
	
	{
		std::fstream fileStream("test.txt", std::ios::app);
		if (fileStream.is_open()) {
			std::streampos tellp_pos = fileStream.tellp(); // Получить текущую позицию указателя записи

			fileStream.seekp(std::ios::beg); // Установить указатель записи в начало файла
			fileStream.seekp(std::ios::cur); // Оставить указатель записи в текущей позиции
			fileStream.seekp(std::ios::end); // Установить указатель записи в конец файла

			// Пример цепочки вызовов:
			// fileStream.seekp(std::ios::beg).seekp(std::ios::cur).seekp(std::ios::end);

			fileStream.seekp(std::ios::beg, -5); // Переместить указатель на 5 байт назад от начала файла
			fileStream.seekp(std::ios::cur, -3); // Переместить указатель на 3 байта назад от текущей позиции
			fileStream.seekp(std::ios::end, -16); // Переместить указатель на 16 байт назад от конца файла
		}

	}
}


#include <ios>
#include <ostream> // output stream <<
#include <istream> // input stream >>
#include <iostream>
#include <fstream>
// #include <sstream>

// Потік

int main()
{
	/*
	-------------------------------- Ієрархія потоків вводу / виводу в С++ --------------------------------
	
	1. std::cout - це стандартний потік виводу, який використовується для нормального виводу інформації у програмі.
	Він буферизується, що означає, що дані зберігаються в пам'яті перед їх надсиланням в консоль/термінал.
	Це може покращити продуктивність, оскільки кілька операторів виводу можна об'єднати в одну операцію.
	
	2. std::cerr - це стандартний потік виводу помилок, який використовується для повідомлень про помилки
	та діагностичного виведення. Він не буферизується, що означає, що дані надсилаються безпосередньо на консоль
	або термінал, як тільки вони записуються. Це гарантує, що повідомлення про помилки відображаються миттєво
	та не втрачаються в разі збою програми.
	
	3. std::clog - це стандартний потік логування, який використовується для реєстрації повідомлень.
	Він буферизується як std::cout, але зазвичай використовується для реєстрації інформації,
	яка не є критичною для роботи програми.

	-------------------------------------------------------------------------------------------------------
	*/

	/*
	-------------------------------------------------------------------------------------------------------

	Переходимо до головної теми цього відео. В ієрарахії потоків вводу/виводу є ще файл fstream (file stream).
	В цьому файлі находяться зразу 3 класи:
	1. ifstream (input file stream) клас, який відповідає за ЗЧИТУВАННЯ даних з файлу.
	2. ofstream (output file stream) клас, який відповідає за ЗАПИС даних у файл.
	3. fstream (file stream) клас, який є об'єднанням двох класів ifstream та ofstream
	
	Клас ifstream наслідується від basic_istream, а отже має той самий інтерфейс + декілька
	нових методів для роботи конкретно з файлами (наприклад ореп, is_open).

	Аналогічна ситуація з класом ofstream. Він наслідується від basic_ostream.
	
	Клас fstream наслідується від класу basic_iostream і комбінує в собі ввід та вивід інформації з файлу чи у файл.

	-------------------------------------------------------------------------------------------------------
	*/

	// ------------------------------ Як поламати потік ? ------------------------------
	// В кожному класі з нашої ієрархії є поле, яке називається _Mystate. Воно має тип int і відповідає за стан потоку.
	// Стан може бути добрим (полагодженим / з яким можна працювати) або поганим (який треба або полагодити
	// або перестити з ним працювати). В ньому записується одне з 4 можливих значень:
	// 1. std::ios::goodbit	-	відповідає за те, що поток працює нормально. Встановлюється за замовчуванням
	//							при створенні потоку.
	// 2. std::ios::eofbit	-	встановлюється тоді, коли при зчитуванні даних з потоку ми зустріли кінець файлу
	// 3. std::ios::failbit	-	встановлюється тоді, коли відбулася помилка, яку можна виправити.
	//							Напрклад коли потік не може читати чи записувати дані із - за тимчасового
	//							збою в мережі чи дані не відповідають очікуванному формату.
	// 4. std::ios::badbit	-	встановлюється тоді, коли відбулася помилка, яку не можна виправити.
	//							Наприклад коли потік не може зчитувати / записувати дані із - за апаратного збою,
	//							чи потік неочікувано закрився.
	// 
	// 
	// Щоб перевірити стан потоку, існують 4 методи: good(), eof(), fail(), bad().
	// Вони повертають true, якщо встановлений один з 4 бітів.
	//
	// Ось приклад на перевірку цих бітів:

	{
		std::cout << "Enter a number: ";
		int number;
		std::cin >> number;
		if (std::cin.good())
		{
			std::cout << "Your number = " << number << std::endl;
		}
		else
		{
			std::cout << "Oops. Something went wrong.\n";
			if (std::cin.bad())
			{
				std::cout << "cin.bad() = true.\n";
			}
			else if(std::cin.fail())
			{
				std::cout << "cin.fail() = true.\n";
			}
			else if (std::cin.eof())
			{
				std::cout << "cin.eof() = true.\n";
			}
		}
	}

	//system("pause");

	// ------------------------------ Як полагодити потік ? ------------------------------
	// 1. Якщо стан потоку має значення std::ios::eofbit, то в такому випадку
	//	  потік дійшов до кінця запису / зчитування і вам треба його закрити та заново відкрити.
	//    Робиться це методами close та ореп.Це відбувається зазвичай при роботі з файлами.
	//
	// 2. Якщо стан потоку має значення std::ios::failbit, τо в такому випадку
	//    ви можете спочатку викликати метод clear(), який встановить стан потоку
	//    заново в значення std::ios::goodbit, а потім почистити потік методом ignore(),
	//    який витягне звідти символи, але не запише їх в потік(щоб він заново не поламався).
	//    Після цього можна продовжити роботу.
	// 
	// 3. Якщо стан потоку має значення std:: ios::badbit, то в такому випадку
	//    ви можете викликати метод clear(), але це не гарантує, що потік зможе спокійно працювати далі,
	//    так як такий біт встановлюється у "невиправних" ситуаціях. Тут рекомендується більше
	//    не працювати з потоком, а відкрити новий (або закрити і відкрити цей).
	//
	// Приклад полагодження:
	{
		std::cout << "Enter a number: ";
		int number;
		std::cin >> number;
		while (!std::cin.good() && !std::cin.fail())
		{
			std::cin.clear();
			std::cout << "Your entered incorrect value. Enter only integer number.\n";
			std::cin.ignore(LLONG_MAX, '\n');
			std::cout << "Enter a number: ";
			std::cin >> number;
		}
	}

	// ------------------------------ Режими відкриття файлу ------------------------------
	// 1. std::ios::in		-	відкрити файл для читання. Якщо файлу не існує - потік "ламається".
	// 2. std::ios::out		-	відкрити файл для запису. Якщо файл існує - його вміст очищається(можливо).
	//							Якщо не існує -  файл створюється.
	// 3. std::ios::app		-	відкрити файл для запису в кінець. Якщо файлу не існує - він створюється.
	// 4. std::ios::trunc	-	використовується з режимом out. Змушує файл очиститися, якщо
	//							в ньому було щось до відкриття.
	// 5. std::ios:ate		-	використовується з іншими режимами. Переміщає вказівник зчитування в кінець файлу.
	// 6. std::ios::binary	-	відкрити файл у бінарному режимі. Використовується з іншими режимами.

	// ------------------------------ Файловий покажчик ------------------------------
	// 
	// peek() - повертає наступний символ відносно курсору читання не зміщуючи курсор
	// tellp(), tellg() - повертають поточну позицію у файлі.
	// 
	// tellg() - повертає позицію курсора читання.	(ifstream)
	// tellp() - повертає позицію курсора зпису.	(ofstream)
	// 
	// 
	// Методи seekp()/seekg() приймають два параметри: вихідна точка (origin), та зміщення від неї (offset)
	// 
	// seekg() - встановлює позицію курсора читання.
	// seekp() - встановлює позицію курсора запису.
	// 
	// Методи які зміщують курсор читання:
	// 
	// ignore()		- Пропускає вказану кількість символів у потоці, зміщуючи курсор на n позицій.
	// get()		- Читає один символ і зміщує курсор на один байт вперед.
	// getline()	- Зчитує рядок і зміщує курсор на наступний рядок.
	// read()		- Читає n байтів і зміщує курсор читання на n байтів вперед.
	// putback()
	// unget()
	// 
	// Методи які зміщують курсор запису:
	// 
	// put()
	// write()
	//
	{
		//std::fstream fileStream()

		std::fstream fileStream("test.txt", std::ios::app);
		if (fileStream.is_open())
		{
			std::streampos tellp_pos = fileStream.tellp();

			std::string str("Hello");

			fileStream << str << " Hello";

			fileStream.seekp(std::ios::beg);
			fileStream.seekp(std::ios::cur);
			fileStream.seekp(std::ios::end);

			// fileStream.seekp(std::ios::beg).seekp(std::ios::cur).seekp(std::ios::end);

			fileStream.seekp(std::ios::beg, -5);
			fileStream.seekp(std::ios::cur, -3);
			fileStream.seekp(std::ios::end, -16);
		}
	}

	return 0;
}